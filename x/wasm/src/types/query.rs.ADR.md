# ADR: Implement `x/wasm::types::query`

## Status
Proposed

## Context

Contracts expose custom query entry points that return JSON. The module also
needs to provide SDK queries for contract state, code info and other metadata.
`wasmd` defines these in [`types/query`](https://github.com/CosmWasm/wasmd/tree/main/x/wasm/types).

## Decision

`query.rs` will declare request and response structs for:

- `QuerySmartContractState`
- `QueryRawContractState`
- `QueryCode`
- `QueryContractInfo`
- `QueryContractsByCode`

Each type derives `Serialize`, `Deserialize` and implements Gears' query
macros so they can be used by CLI, REST and gRPC interfaces. The design mirrors
the Go definitions but uses Rust idioms and `cosmwasm_std` data structures where
appropriate.

### Detailed Specification

1. **QuerySmartContractState** – Takes a contract address and arbitrary JSON
   payload. Returns raw JSON from the contract. The struct should hold the
   address as `Address` from the `address` crate and the query message as
   `Binary` from `cosmwasm_std`. Responses are `Binary` as well.
2. **QueryRawContractState** – Allows retrieving a raw KV pair from a
   contract's storage. Contains a contract address and a key as `Vec<u8>`. The
   keeper will route this directly to storage bypassing the VM.
3. **QueryCode** – Fetches the original wasm bytecode for a given code ID.
   Response includes the byte array and metadata such as creator address and
   checksum similar to `wasmd/types/query.pb.go`.
4. **QueryContractInfo** – Returns metadata about a contract instance including
   code ID, admin, label and IBC port if present.
5. **QueryContractsByCode** – Pagination request listing all contracts that were
   instantiated from a specific code ID. Uses the `extensions::pagination` types
   for page/limit options.

The file will also define an overarching `enum WasmQuery` implementing
`gears::derive::AppQuery` so the ABCI handler can deserialize incoming JSON or
protobuf `Any` payloads. This mirrors the `QueryServer` interface in wasmd which
is generated from `query.proto` and implemented in
[`grpcquerier`](https://github.com/CosmWasm/wasmd/blob/main/x/wasm/client/grpc/grpc.go).

Every request/response pair will include documentation examples showing typical
JSON encoding to aid users of the REST API.

## Consequences

Having a shared set of query types ensures consistency across all client
interfaces and the ABCI handler.

## Implementation Notes

### Pagination and Limits

`QueryContractsByCode` should embed the `PageRequest` struct from
`extensions::pagination` to allow clients to paginate through large result sets.
The file should document default limits and how they relate to the corresponding
`PageResponse`. This mirrors the behaviour in
[`wasmd`](https://github.com/CosmWasm/wasmd/blob/main/x/wasm/keeper/grpc_query.go#L97)
where pagination is handled via gRPC metadata.

### Address Types

All query request structs use the `Address` type from the `address` crate. This
ensures Bech32 decoding is performed uniformly across modules. When converting
from the protobuf messages generated by `prost`, the `TryFrom` implementation
should validate the address string and return a meaningful error if decoding
fails. This validation step replicates the checks in the Go implementation's
`ParseAddressOrReturnErr` helper.

### Serialization Examples

Include rustdoc examples demonstrating how to encode queries as JSON. For
instance:

```rust
/// ```json
/// {"contract_addr":"cosmos1...","query_msg":{"balance":{"address":"..."}}}
/// ```
```

Such documentation helps client developers craft correct requests without
consulting the protobuf definitions directly.

### Testing Strategy

Unit tests should verify that each struct serializes to the expected protobuf
format and that unknown fields are ignored. Integration tests running a local
node will issue queries via the CLI and confirm that the responses match those
produced by `wasmd` for the same contracts. Mock contracts stored in
`assets/` can return predetermined JSON to simplify assertions.

## Rationale

The design draws heavily on the established patterns from `wasmd` and the
`wasmvm` bindings. By adhering to these specifications we maintain compatibility
with existing Cosmos SDK tooling while providing a Rust-friendly interface for
Gears-based nodes.

